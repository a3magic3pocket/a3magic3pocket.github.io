<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53)" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="설명 certbot에서는 여러 방식으로 웹서버 소유권 인증을 지원한다. getting-certificates-and-choosing-plugins 와일드카드 인증서를 발급받기 위해서는 DNS를 사용하여 인증을 받아야 한다. 여러 DNS를 지원하지만 여기서는 AWS Route53 기준으로 설명한다. 최초 발급 방법과 자동갱신 방법을 함께 설명한다. 예시에서 인증서를 발급할 도메인은 helloworld.com이라고 가정한다." /><meta property="og:description" content="설명 certbot에서는 여러 방식으로 웹서버 소유권 인증을 지원한다. getting-certificates-and-choosing-plugins 와일드카드 인증서를 발급받기 위해서는 DNS를 사용하여 인증을 받아야 한다. 여러 DNS를 지원하지만 여기서는 AWS Route53 기준으로 설명한다. 최초 발급 방법과 자동갱신 방법을 함께 설명한다. 예시에서 인증서를 발급할 도메인은 helloworld.com이라고 가정한다." /><link rel="canonical" href="https://a3magic3pocket.github.io/posts/cerbot-route53/" /><meta property="og:url" content="https://a3magic3pocket.github.io/posts/cerbot-route53/" /><meta property="og:site_name" content="의사줌치" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-11-20T18:29:45+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"설명 certbot에서는 여러 방식으로 웹서버 소유권 인증을 지원한다. getting-certificates-and-choosing-plugins 와일드카드 인증서를 발급받기 위해서는 DNS를 사용하여 인증을 받아야 한다. 여러 DNS를 지원하지만 여기서는 AWS Route53 기준으로 설명한다. 최초 발급 방법과 자동갱신 방법을 함께 설명한다. 예시에서 인증서를 발급할 도메인은 helloworld.com이라고 가정한다.","url":"https://a3magic3pocket.github.io/posts/cerbot-route53/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://a3magic3pocket.github.io/posts/cerbot-route53/"},"headline":"certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53)","dateModified":"2024-02-19T12:18:35+09:00","datePublished":"2023-11-20T18:29:45+09:00","@context":"https://schema.org"}</script><title>certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53) | 의사줌치</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="의사줌치"><meta name="application-name" content="의사줌치"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-5NQ41XXW83"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-5NQ41XXW83'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar-crop.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">의사줌치</a></div><div class="site-subtitle font-italic">부정확한 정보를 <br /> 담고 있을 수 있습니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/a3magic3pocket" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['a3magic3pocket','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 의사줌치 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 20, 2023, 6:29 PM +0900" prep="on" > Nov 20, 2023 <i class="unloaded">2023-11-20T18:29:45+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Feb 19, 2024, 12:18 PM +0900" prefix="Updated " > Feb 19, 2024 <i class="unloaded">2024-02-19T12:18:35+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2049 words">11 min</span></div></div><div class="post-content"><h2 id="설명">설명</h2><ul><li>certbot에서는 여러 방식으로 웹서버 소유권 인증을 지원한다.<br /> <a href="https://eff-certbot.readthedocs.io/en/stable/using.html#getting-certificates-and-choosing-plugins" target="_blank">getting-certificates-and-choosing-plugins</a><li>와일드카드 인증서를 발급받기 위해서는 DNS를 사용하여 <br /> 인증을 받아야 한다.<li>여러 DNS를 지원하지만 여기서는 AWS Route53 기준으로 설명한다.<li>최초 발급 방법과 자동갱신 방법을 함께 설명한다.<li>예시에서 인증서를 발급할 도메인은 helloworld.com이라고 가정한다.</ul><h2 id="기본-방식">기본 방식</h2><ul><li>서버에서 nginx 도커를 띄워 웹을 띄운다.<li>cerbot 도커를 이용하여 인증서를 획득한다.<li>자동갱신을 위해 nginx 도커 인증서 경로를 <br /> 호스트서버의 cerbot 인증서 경로와 연결한다.</ul><h2 id="certbot-dns-인증">certbot DNS 인증</h2><ul><li>certbot 인증 전 과정<ul><li>nginx를 띄우고 Route 53 DNS에서 서버IP와 도메인을 연결한다.<li>이를 통해 도메인을 입력하여 서버로 http 접속이 가능한 상태가 된다.</ul><li>certbot DNS 인증 및 인증서 발급<ul><li>명령<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> certbot <span class="se">\ </span> 
      <span class="nt">-v</span> <span class="s1">'/etc/letsencrypt:/etc/letsencrypt'</span> <span class="se">\ </span> 
      <span class="nt">-v</span> <span class="s1">'/var/lib/letsencrypt:/var/lib/letsencrypt'</span> <span class="se">\ </span> 
      certbot/dns-route53 certonly <span class="nt">--dns-route53</span> <span class="nt">-d</span> <span class="s1">'*.helloworld.com'</span> <span class="nt">-d</span> <span class="s1">'helloworld.com'</span> <span class="nt">--preferred-challenges</span> dns <span class="nt">--server</span> https://acme-v02.api.letsencrypt.org/directory  
</pre></table></code></div></div><li>명령 설명<ul><li>cerbot/dns-route53<ul><li>DNS route53 용 이미지를 사용한다.<br /> <a href="https://hub.docker.com/r/certbot/dns-route53" target="_blank">certbot/dns-route53 이미지</a></ul><li>-v ‘/etc/letsencrypt:/etc/letsencrypt’ <br /> -v ‘/var/lib/letsencrypt:/var/lib/letsencrypt’<ul><li>certbot 컨테이너 인증서 경로와 호스트서버 볼륨을 연결한다.</ul><li>-d ‘*.helloworld.com’ -d ‘helloworld.com’<ul><li>인증서를 발급할 도메인 목록을 지정한다.</ul><li>–dns-route53<ul><li>dns를 route53을 사용함을 알려준다.</ul><li>–rm<ul><li>컨테이너는 명령 실행 후 자동으로 삭제한다.</ul></ul><li>명령 실행 후<ul><li>명령 실행 후에는 여러 질문이 나오는데 적당히 대답한다.<li>아래 질문이 나왔을때 키를 복사한 뒤 잠시 창을 최초화하고 대기한다.<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Please deploy a DNS TXT record under the name  
_acme-challenge.helloworld.com with the following value:  
                    
<span class="o">[</span>it-is-my-key]  
                    
Before continuing, verify the record is deployed.  
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
Press Enter to Continue  
</pre></table></code></div></div></ul><li>복사한 키를 Route53 DNS에 TXT record로 등록한다.<ul><li>AWS 콘솔에서 ‘검색’에 Route53을 검색하고 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/00-search-route53.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/00-search-route53.jpg" width="80%" height="80%" /></a></ul><li>(왼쪽 사이드바 메뉴) “대시보드 &gt; 호스팅영역”을 클릭한다.<li>만약 “호스팅 영역 이름”에 인증서를 발급하고자 하는 <br /> 도메인(여기서는 helloworld.com)이 있다면 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/01-create-hosting-area.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/01-create-hosting-area.jpg" width="80%" height="80%" /></a></ul><li>없다면 “호스팅 영역 생성” 버튼을 눌러 생성한 후<br /> 도메인을 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/02-select-hosting-area.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/02-select-hosting-area.jpg" width="80%" height="80%" /></a></ul><li>레코드 생성을 누른다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/03-create-record.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/03-create-record.jpg" width="80%" height="80%" /></a></ul><li>레코드 이름에 “_acme-challenge”를 입력한다.<li>레코드 유형을 “TXT”를 선택한다.<li>값에 이전에 복사한 키를 붙여넣는다.<li>“다른 레코드 추가” 버튼을 누른다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/04-record-config.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/04-record-config.jpg" width="80%" height="80%" /></a></ul></ul><li>TXT record 확인<ul><li>TTL(tiemto live) 300초는 레코드가 적용되기 까지 300초가 걸린다는 뜻<li><a href="https://toolbox.googleapps.com/apps/dig/?lang=ko#A/" target="_blank">Google 관리 콘솔도구 상자</a>에서 _acme-challenge.helloworld.com 검색 시<br /> 키가 노출될때까지 기다린다.<li>value에 키가 정확히 노출되면 cerbot 명령창으로 되돌아간다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/05-google-console.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/05-google-console.jpg" width="80%" height="80%" /></a></ul></ul><li>cerbot 인증서 발급 확인<ul><li>cerbot 명령창에서 Enter 키를 누르면 발급결과가 나온다.<br /> 문제가 없다면 인증서가 발급되었을 것이다.<li>발급된 인증서는 호스트서버 /etc/letsencrypt/live 하위에 저장된다.</ul><li>nginx에 인증서 올리기<ul><li>nginx.conf에서 ssl 설정을 해준다.<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c"># nginx.conf  </span>
server <span class="o">{</span>  
    listen 80 default_server<span class="p">;</span>  
                    
    server_name _<span class="p">;</span>  
                    
    <span class="k">return </span>301 https://<span class="nv">$host$request_uri</span><span class="p">;</span>  
<span class="o">}</span>  
                    
server <span class="o">{</span>  
    listen 443 ssl<span class="p">;</span>  
                    
    server_name api.coinlocker.link<span class="p">;</span>  
    underscores_in_headers on<span class="p">;</span>  
    server_tokens off<span class="p">;</span>  
    <span class="c">#ignore_invalid_headers off;  </span>
                    
    ssl_certificate /etc/ssl/live/fullchain1.pem<span class="p">;</span>  
    ssl_certificate_key /etc/ssl/live/privkey1.pem<span class="p">;</span>  
                    
    location / <span class="o">{</span>  
        <span class="c"># your setting ...  </span>
    <span class="o">}</span>  
<span class="o">}</span>
                    
</pre></table></code></div></div><li>이제 호스트서버 인증서 경로와 웹 nginx 서비스 인증서 경로를 연결한다.<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c"># docker-compose.yml  </span>
version: <span class="s2">"3.9"</span>  
                    
services:  
  nginx:  
    image: nginx:latest  
    ports:  
      - 80:80  
      - 443:443  
    configs:  
      - <span class="nb">source</span>: nginx-config  
        target: /etc/nginx/conf.d/default.conf  
    volumes:  
      - /etc/letsencrypt/live/helloworld.com/fullchain.pem:/etc/ssl/live/fullchain1.pem  
      - /etc/letsencrypt/live/helloworld.com/privkey.pem:/etc/ssl/live/privkey1.pem  
                    
configs:  
  nginx-config:  
    file: <span class="s2">"my-nginx-conf/nginx.conf"</span>  
</pre></table></code></div></div><li>컨테이너 생성<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker compose <span class="nt">-f</span> ./docker-compose.yml up  
</pre></table></code></div></div></ul><li>인증서 확인<ul><li>인터넷 브라우저를 켜고 <br /> https://helloworld.com 접속 시 ssl 적용이 되었는지 확인한다.</ul></ul></ul><h2 id="certbot-dns-자동갱신">certbot DNS 자동갱신</h2><ul><li>설명<ul><li>DNS 인증은 TXT레코드에 지정된 키를 등록하는 방식으로 이뤄진다.<li>이 과정을 자동으로 처리해야만 인증서 자동갱신을 할 수 있다.<li>AWS Route53 DNS를 사용 중이므로 <br /> DNS 사용 권한이 있는 IAM을 생성하고<br /> 인증서를 자동갱신 서버에 IAM을 등록 후 자동갱신 스크립트를 실행한다.</ul><li>IAM 만들기<ul><li><a href="https://certbot-dns-route53.readthedocs.io/en/stable/" target="_blank">certbot-dns-route53 공식문서</a>에 필요한 권한이 적혀있다.<div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">  
    </span><span class="nl">"Version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2012-10-17"</span><span class="p">,</span><span class="w">  
    </span><span class="nl">"Id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"certbot-dns-route53 sample policy"</span><span class="p">,</span><span class="w">  
    </span><span class="nl">"Statement"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">  
        </span><span class="p">{</span><span class="w">  
            </span><span class="nl">"Effect"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Allow"</span><span class="p">,</span><span class="w">  
            </span><span class="nl">"Action"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">  
                </span><span class="s2">"route53:ListHostedZones"</span><span class="p">,</span><span class="w">  
                </span><span class="s2">"route53:GetChange"</span><span class="w">  
            </span><span class="p">],</span><span class="w">  
            </span><span class="nl">"Resource"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">  
                </span><span class="s2">"*"</span><span class="w">  
            </span><span class="p">]</span><span class="w">  
        </span><span class="p">},</span><span class="w">  
        </span><span class="p">{</span><span class="w">  
            </span><span class="nl">"Effect"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Allow"</span><span class="p">,</span><span class="w">  
            </span><span class="nl">"Action"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">  
                </span><span class="s2">"route53:ChangeResourceRecordSets"</span><span class="w">  
            </span><span class="p">],</span><span class="w">  
            </span><span class="nl">"Resource"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">  
                </span><span class="s2">"arn:aws:route53:::hostedzone/YOURHOSTEDZONEID"</span><span class="w">  
            </span><span class="p">]</span><span class="w">  
        </span><span class="p">}</span><span class="w">  
    </span><span class="p">]</span><span class="w">  
</span><span class="p">}</span><span class="w">  
</span></pre></table></code></div></div><li>AWS 콘솔에서 ‘검색’에 iam을 검색하고 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/06-search-iam.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/06-search-iam.jpg" width="80%" height="80%" /></a></ul><li>(왼쪽 사이드바 메뉴) “정책”을 클릭하고 “정책 생성” 버튼을 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/07-create-policy.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/07-create-policy.jpg" width="80%" height="80%" /></a></ul><li>JSON을 클릭하고 certbot-dns-route53 공식문서 권한을 복사 붙여넣기 한다.<br /> “다음” 버튼을 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/08-policy-config.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/08-policy-config.jpg" width="80%" height="80%" /></a></ul><li>정책이름(예시에서는 helloworld) 적고, “정책 생성” 버튼을 클릭한다.<li>(왼쪽 사이드바 메뉴) “사용자”를 클릭하고 ‘사용자 생성’ 버튼을 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/09-create-user.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/09-create-user.jpg" width="80%" height="80%" /></a></ul><li>사용자 세부 정보에서 원하는 “사용자 이름”을 입력하고 <br /> “다음” 버튼을 클릭한다.<li>“직접 정책 연결”을 클릭하고 이전에 생성한 정책명을 검색 후 선택한다.<br /> 그리고 “다음” 버튼을 클릭한다.<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/10-select-permissions.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/10-select-permissions.jpg" width="80%" height="80%" /></a></ul><li>“사용자 생성” 버튼을 클릭하여 사용자를 생성한다.</ul><li>IAM 엑세스 키 만들기<ul><li>(왼쪽 사이드바 메뉴) “사용자”를 클릭하고 <br /> 엑세스 키 1 아래 엑세스 키 만들기 클릭<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/11-create-access-key.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/11-create-access-key.jpg" width="80%" height="80%" /></a></ul><li>Command Line interface(CLI) 선택, 확인 체크박스 선택 후 “다음” 버튼 클릭<li>엑세스 키 만들기 버튼 클릭<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/12-create-access-key-2.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/12-create-access-key-2.jpg" width="80%" height="80%" /></a></ul><li>엑세스 키와 비밀 엑세스키를 메모장에 복사 붙여넣기<ul><li><a href="/assets/img/2023-11-20-cerbot-route53/13-create-access-key-3.jpg" target="_blank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/2023-11-20-cerbot-route53/13-create-access-key-3.jpg" width="80%" height="80%" /></a></ul></ul><li>certbot 인증 시 IAM 엑세스 키 사용하기<ul><li><a href="https://certbot-dns-route53.readthedocs.io/en/stable/index.html#config-ini" target="_blank">certbot-dns-route53 설정예시</a>를 보면<br /> IAM 엑세스 키를 환경변수로 설정하는 것을 볼 수 있다.<li>AWS_ACCESS_KEY_ID와 AWS_SECRET_ACCESS_KEY를 파일로 저장한다.<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="s2">"your-access_key"</span> <span class="o">&gt;&gt;</span> AWS_ACCESS_KEY_ID  
<span class="nb">echo</span> <span class="s2">"your-secret_access_key"</span> <span class="o">&gt;&gt;</span> AWS_SECRET_ACCESS_KEY  
</pre></table></code></div></div><li>certbot 인증명령 실행<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>    docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> certbot <span class="se">\ </span> 
      <span class="nt">-v</span> <span class="s1">'/etc/letsencrypt:/etc/letsencrypt'</span> <span class="se">\ </span> 
      <span class="nt">-v</span> <span class="s1">'/var/lib/letsencrypt:/var/lib/letsencrypt'</span> <span class="se">\ </span> 
      <span class="nt">-e</span> <span class="s2">"AWS_ACCESS_KEY_ID=</span><span class="si">$(</span><span class="nb">cat</span> ./AWS_ACCESS_KEY_ID<span class="si">)</span><span class="s2">"</span> <span class="nt">-e</span> <span class="s2">"AWS_SECRET_ACCESS_KEY=</span><span class="si">$(</span><span class="nb">cat</span> ./AWS_SECRET_ACCESS_KEY<span class="si">)</span><span class="s2">"</span> <span class="se">\ </span> 
      certbot/dns-route53 certonly <span class="nt">--dns-route53</span> <span class="nt">-d</span> <span class="s1">'*.helloworld.com'</span> <span class="nt">-d</span> <span class="s1">'helloworld.com'</span> <span class="nt">--preferred-challenges</span> dns <span class="nt">--server</span> https://acme-v02.api.letsencrypt.org/directory  
                
</pre></table></code></div></div><li>정상적으로 처리되었다면 ENTER를 입력하라는 프롬프트 없이<br /> 인증서 발급이 완료된다.</ul><li>cron에 등록<ul><li>certbot 인증명령을 스크립트 파일(예시에서는 set_ssl.sh)로 만든다.<li>certbot 인증서는 90일 동안 유효하고 30일 전부터 갱신할 수 있으므로<br /> 2달 마다 실행하도록 cron에 등록한다.<div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>crontab <span class="nt">-e</span>  
                
<span class="c"># 에디터가 실행되면 아래 내용 입력 후 저장  </span>
0 0 0 1 1/2 ? <span class="k">*</span> bash /home/ubuntu/my_project/set_ssl.sh  
</pre></table></code></div></div></ul></ul><h2 id="덧붙이는-말">덧붙이는 말</h2><ul><li>AWS Route53 호스팅 영역은 도메인 가격과 별개로<br /> 월마다 1달러 정도 비용을 요구한다.<br /> 그렇기에 필요한 호스팅 영역만 생성하는 것이 좋다.</ul><h2 id="참고">참고</h2><ul><li><a href="https://certbot-dns-route53.readthedocs.io/en/stable/" target="_blank">certbot-dns-route53 공식문서</a><li><a href="https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins" target="_blank">User Guide — Certbot 2.6.0 documentation eff-certbot.readthedocs.io</a><li><a href="https://hub.docker.com/r/certbot/dns-route53" target="_blank">certbot/dns-route53 - Docker Image Docker Hub</a><li><a href="https://lynlab.co.kr/blog/72" target="_blank">Docker로 간단하게 Let’s Encrypt 와일드카드 인증서 발급받기</a><li><a href="https://www.lesstif.com/system-admin/dns-txt-record-let-s-encrypt-ssl-59343172.html" target="_blank">DNS TXT Record 로 Let’s Encrypt SSL 인증서 발급 받기</a><li><a href="https://oasisfores.com/letsencrypt-wildcard-ssl-certificate/" target="_blank">Let’s Encrypt 와일드카드로 여러개의 서브도메인 인증서 한번에 발급받기</a><li><a href="https://arcadian.cloud/aws/2022/03/22/how-to-find-hosted-zone-id-in-route53-aws-in-3-clicks/" target="_blank">How to Find Hosted Zone ID in Route53 AWS in 3 Clicks arcadian.cloud”</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/certbot/'>Certbot</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/certbot/" class="post-tag no-text-decoration" >certbot</a> <a href="/tags/route53/" class="post-tag no-text-decoration" >route53</a> <a href="/tags/nginx/" class="post-tag no-text-decoration" >nginx</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53) - 의사줌치&url=https://a3magic3pocket.github.io/posts/cerbot-route53/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53) - 의사줌치&u=https://a3magic3pocket.github.io/posts/cerbot-route53/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=certbot, DNS 인증 시 자동 갱신하게 만들기(AWS Route 53) - 의사줌치&url=https://a3magic3pocket.github.io/posts/cerbot-route53/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/kafka-large-scale-event-processing-architecture-and-performance-comparison/">Kafka를 활용한 대용량 이벤트 처리 구조 설계와 성능 비교</a><li><a href="/posts/experimenting-with-blue-green-deployments/">블루 - 그린 배포 실험</a><li><a href="/posts/spring-kafka-latest-message-pub-sub-config/">Spring Kafka에서 최신 메시지만 소비하는 Pub/Sub 방식 설정</a><li><a href="/posts/solving-concurrency-problems-with-performance-in-mind/">동시성 문제 해결 방안 성능 실험</a><li><a href="/posts/exploring-authentication-options/">인증방식 고민</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/elasticsearch/">elasticsearch</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/kafka-streams/">kafka-streams</a> <a class="post-tag" href="/tags/nest/">nest</a> <a class="post-tag" href="/tags/react/">react</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/nginx-aws-cloudfront-reverse-proxy-error/"><div class="card-body"> <span class="timeago small" > Sep 26, 2023 <i class="unloaded">2023-09-26T22:03:12+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>nginx, AWS cloudfront로 리버스 프록시 설정 에러</h3><div class="text-muted small"><p> 현상 기존 CDN을 AWS cloudfront + s3 CDN(이하 cloudfront)으로 변경하였다. proxy_pass 경로를 기존 CDN URL에서 cloudfront URL로 변경하였지만 포워딩 되지 않고 에러가 발생하였다. 에러 원문 SSL: error:14094410:SSL routines:ssl3_read_byt...</p></div></div></a></div><div class="card"> <a href="/posts/cerbot-webroot/"><div class="card-body"> <span class="timeago small" > Nov 20, 2023 <i class="unloaded">2023-11-20T18:28:45+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>certbot, webroot 방식으로 인증서 발급받기</h3><div class="text-muted small"><p> 설명 webroot 방식으로 certbot 인증서를 발급받는다. certbot 도커를 활용하여 인증서를 발급 받는다. 예시에서 인증 받을 도메인은 helloworld.com으로 가정한다. 사전 준비 nginx를 띄우고 Route 53 DNS에서 서버IP와 도메인을 연결한다. 이를 통해 도메인을 입력하여 서버로 http 접속이 가능...</p></div></div></a></div><div class="card"> <a href="/posts/db-based-leader-election-lock/"><div class="card-body"> <span class="timeago small" > Apr 11 <i class="unloaded">2025-04-11T22:35:03+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DB를 활용한 리더선출락 구현</h3><div class="text-muted small"><p> 개요 여러 컨테이너가 동시에 실행되는 환경에서는 특정 작업(이하 리더 작업)을 오직 하나의 컨테이너만 수행해야 할 때가 있다. 리더 작업은 리더가 주기적으로 실행하고 리더가 아닌 다른 컨테이너는 대기해야한다. 만약 리더가 다운되어 리더 작업이 불가능한 경우 최대한 빨리 대기하고 있는 다른 컨테이너 중 하나를 리더로 선출한 뒤 리더 작업...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/cerbot-webroot/" class="btn btn-outline-primary" prompt="Older"><p>certbot, webroot 방식으로 인증서 발급받기</p></a> <a href="/posts/solana-wallet-signin/" class="btn btn-outline-primary" prompt="Newer"><p>solana DApp 인증 구현</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/a3magic3pocket">의사줌치</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/elasticsearch/">elasticsearch</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/kafka-streams/">kafka streams</a> <a class="post-tag" href="/tags/nest/">nest</a> <a class="post-tag" href="/tags/react/">react</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://a3magic3pocket.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
